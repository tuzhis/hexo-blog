{"pages":[{"title":"","text":"宝贝,公益404带你们回家","link":"/404.html"},{"title":"关于我","text":"技术学习偏好后端，同时广泛阅读各种技术的———&gt;简介（微笑脸 折腾党，折腾把玩各种软件 折腾硬件，水平为业余爱好把玩 折腾路由，偏爱OPENWRT系统 涉猎广泛，逐步深入 仍有很多不足，时间管理渣渣 还有的等我想到再写。。。。。","link":"/about/index.html"}],"posts":[{"title":"算法4学习-1.3.2 下压(LIFO)栈(动态调整数组大小的实现)","text":"通过数组的方式实现栈的基本功能,看书看到这了就写个复习下。 知识点主要包含泛型、迭代、动态1/2大小、避免游离。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Iterator;/** * 下压(LIFO)栈(动态调整数组大小的实现) * * Created by tuzhis on 2016年1月14日. */public class ReSizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt; { private Item[] a = (Item[]) new Object[1]; private int N = 0; public boolean isEmpty() { return N == 0; } public int size() { return N; } private void resize(int max) { Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) { temp[i] = a[i]; } a = temp; } public void push(Item item) { if (N == a.length) resize(2 * a.length); a[N++] = item; } public Item pop() { Item item = a[--N]; a[N] = null; // 避免对象游离 if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; } @Override public Iterator&lt;Item&gt; iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator&lt;Item&gt; { private int i = N; @Override public boolean hasNext() { return i &gt; 0; } @Override public Item next() { return a[--i]; } }}","link":"/2016/01/14/ArrayStack/"},{"title":"解决scrollview嵌套布局带来的惯性丢失和不流畅问题","text":"ScrollView 嵌套ViewPage，如果事件没有传递ViewPage在需要滑动的时候会遇到不流畅的问题，ScrollView 嵌套RecyclerView又会有一个惯性丢失的问题。 解决方法对于以上两种情况，一个是ScrollView把不该处理的滑动方向处理了，这时候屏蔽一个方向下放到子view处理即可，对于嵌套RecyclerView的则应该完全交由ScrollView处理。单独的例子可以找到很多，这里贴一个自用的两种结合的例子。 需求：ScrollView同时嵌套了ViewPage和RecyclerView，对于左右事件完全交由子View处理，对于竖直事件完全交由ScrollView处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import android.content.Context;import android.util.AttributeSet;import android.view.GestureDetector;import android.view.MotionEvent;import android.view.ViewConfiguration;import android.widget.ScrollView;/** * 屏蔽左右滑动事件&amp;&amp;解决滑动惯性丢失 * * @author zhisheng created on 2016/3/11 0011. */public class CustomScrollView extends ScrollView { private GestureDetector mGestureDetector; private float downY; private float mTouchSlop; public CustomScrollView(Context context) { super(context); mGestureDetector = new GestureDetector(context, new YScrollDetector()); setFadingEdgeLength(0); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); } public CustomScrollView(Context context, AttributeSet attrs) { super(context, attrs); mGestureDetector = new GestureDetector(context, new YScrollDetector()); setFadingEdgeLength(0); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); } public CustomScrollView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); mGestureDetector = new GestureDetector(context, new YScrollDetector()); setFadingEdgeLength(0); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); } @Override public boolean onInterceptTouchEvent(MotionEvent e) { int action = e.getAction(); switch (action) { case MotionEvent.ACTION_DOWN: downY = e.getRawY(); break; case MotionEvent.ACTION_MOVE: float moveY = e.getRawY(); if ((Math.abs(moveY - downY) &gt; mTouchSlop) &amp;&amp; mGestureDetector.onTouchEvent(e)) { return true; } break; } return super.onInterceptTouchEvent(e) &amp;&amp; mGestureDetector.onTouchEvent(e); } //如果是左右滑动则返回false class YScrollDetector extends GestureDetector.SimpleOnGestureListener { @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { return Math.abs(distanceY) &gt; Math.abs(distanceX); } }}","link":"/2016/04/29/CustomScrollView/"},{"title":"算法4学习-1.3.1.7 Dijkstra双栈算术表达式求值法","text":"决定今晚开始看算法4。虽然正值考试期间,但是总要有个开始不是么? 书上基础部分的例子,很不错的思路，改动的地方是把原书中的if嵌套改成了switch。 运行结果 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Stack;import edu.princeton.cs.algs4.StdIn;import edu.princeton.cs.algs4.StdOut;/*** Created by tuzhis on 2016年1月11日.*/public class Evaluate { public static void main(String[] args){ Stack&lt;String&gt; ops = new Stack&lt;String&gt;(); Stack&lt;Double&gt; vals = new Stack&lt;Double&gt;(); StdOut.println(&quot;% java Evaluate&quot;); while (!StdIn.isEmpty()){ //读取字符,如果是运算符则压入栈 String s = StdIn.readString(); switch (s) { case &quot;(&quot;: break; case &quot;+&quot;: case &quot;-&quot;: case &quot;*&quot;: case &quot;/&quot;: case &quot;sqrt&quot;: ops.push(s); break; case &quot;)&quot;: String op = ops.pop(); double v = vals.pop(); switch (op) { case &quot;+&quot;: v = vals.pop() + v; break; case &quot;-&quot;: v = vals.pop() - v; break; case &quot;*&quot;: v = vals.pop() * v; break; case &quot;/&quot;: v = vals.pop() / v; break; case &quot;sqrt&quot;: v = Math.sqrt(v); break; default: break; } vals.push(v); break; //如果字符既非运算符也不是括号，将它作为double值压入栈 default: vals.push(Double.parseDouble(s)); break; } } StdOut.println(vals.pop()); }}","link":"/2016/01/12/Dijkstra/"},{"title":"算法4学习-1.3.3.8 下压(LIFO)栈(链表实现)","text":"上一篇的链表实现 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Iterator;/** * 下压(LIFO)栈(链表实现) * * Created by tuzhis on 2016年1月14日. */public class ReSizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; // 栈顶(最近添加的元素) private int N; // 元素数量 private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } public void push(Item item) { Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; } public Item pop() { Item item = first.item; first = first.next; N--; return item; } @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } }}","link":"/2016/01/15/ListStack/"},{"title":"Linux下OpenOffice安装和转换格式","text":"偶然的机会测试了下OpenOffice的转换功能，记录下过程。 安装OpenOffice组件（以4.1.2版本为例）1. 下载在OpenOffice官网下载相应的版本。需要注意的是rpm包主要用于redhat及分支如redhat，centos，Fedora等，而deb包主要用于debian及分支如debian，ubuntu等。 2. 解压包1tar zxvf Apache_OpenOffice_4.1.2_Linux_x86-64_install-deb_zh-CN.tar.gz 3. 通过包管理器安装1234#redhat分支rpm -ivh zh-CN/RPMS/*.rpm#debain分支sudo dpkg -i zh-CN/DEBS/*.deb 1234567#【以下内容为可选安装】#作为桌面版使用的安装desktop-integration目录下对应的包可生成相应的快捷方式#redhat分支rpm -ivh zh-CN/RPMS/desktop-integration/openoffice4.1.2-redhat-menus-4.1.2-9782.noarch.rpm#debain分支（第一行解决与libreoffice冲突）sudo apt-get purge libreoffice*sudo dpkg -i zh-CN/DEBS/desktop-integration/*.deb 测试1. 服务启动测试安装后主目录在/opt/openoffice4下,注意OpenOffice需要Java环境支持尝试以后台服务方式启动监听,执行完毕无错误仅返回进程号 1/opt/openoffice4/program/soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard &amp; 查看是否存在8100的监听端口 1netstat -nlt 2. 转换测试若服务启动正常则开始转换测试，可以在后台保持监听服务或者仅在转换时启动服务。这里参考着改写了一个仅在转换时启动服务的Java版本测试程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/**依赖jurt、juh、ridl、unoil、jodconverter-core、commons-io库，前四个库可在OpenOffice主目录中找到*依赖库打包http://download.csdn.net/detail/tuzhis/9377605*转换后在相同目录下生成对应文件*需要转换成其他类型的改程序里对应扩展名即可。*/import java.io.File;import java.util.regex.Pattern;import org.artofsolving.jodconverter.OfficeDocumentConverter;import org.artofsolving.jodconverter.office.DefaultOfficeManagerConfiguration;import org.artofsolving.jodconverter.office.OfficeManager;public class WordToPdf { public static void main(String[] args) { word2pdf(&quot;/home/tu/works/test.doc&quot;); System.out.println(&quot;finish&quot;); } public static void word2pdf(String inputFilePath) { DefaultOfficeManagerConfiguration config = new DefaultOfficeManagerConfiguration(); String officeHome = getOfficeHome(); config.setOfficeHome(officeHome); OfficeManager officeManager = config.buildOfficeManager(); officeManager.start(); OfficeDocumentConverter converter = new OfficeDocumentConverter(officeManager); String outputFilePath = getOutputFilePath(inputFilePath); File inputFile = new File(inputFilePath); if (inputFile.exists()) { File outputFile = new File(outputFilePath); if (!outputFile.getParentFile().exists()) { outputFile.getParentFile().mkdirs(); } converter.convert(inputFile, outputFile); } officeManager.stop(); } public static String getOutputFilePath(String inputFilePath) { String outputFilePath = inputFilePath.replaceAll(&quot;.doc&quot;, &quot;.html&quot;); return outputFilePath; } public static String getOfficeHome() { String osName = System.getProperty(&quot;os.name&quot;); if (Pattern.matches(&quot;Linux.*&quot;, osName)) { return &quot;/opt/openoffice4&quot;; } else if (Pattern.matches(&quot;Windows.*&quot;, osName)) { return &quot;D:/Program Files/OpenOffice4&quot;; } else if (Pattern.matches(&quot;Mac.*&quot;, osName)) { return &quot;/Application/OpenOffice.org.app/Contents&quot;; } return null; }} FAQ 直接利用后台服务转换的Java程序片段见第二个参考网址 直接利用后台服务转换的Python程序片段见第三个参考网址 一般转换还会用到swftools，见补充 补充12345678910#swftools安装wget http://www.swftools.org/swftools-2013-04-09-1007.tar.gztar zxvf swftools-2013-04-09-1007.tar.gzcd swftools-2013-04-09-1007./configure --prefix=/usr/swftoolsmakesudo make install#设置环境变量并立即生效sudo echo 'export PATH=$PATH:/usr/swftools/bin/' &gt;&gt;/etc/profilesource /etc/profile 参考 http://titanseason.iteye.com/blog/1471606http://blog.csdn.net/niuhea/article/details/7749684http://blog.csdn.net/catoop/article/details/42527349","link":"/2015/12/25/OpenOffice/"},{"title":"算法4学习-1.3.3.9 Queue链表实现","text":"继续上一节,队列的实现，背包差不多就不写出来了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Iterator;/** * FIFO队列 Created by tuzhis on 2016年1月15日. */public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; // 指向最早添加的节点的链接 private Node last; // 指向最近添加的节点的链接 private int N; // 队列中的元素个数 private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } public void enqueue(Item item) { Node oldNode = last; last.item = item; last.next = null; if (isEmpty()) first = last; else oldNode.next = last; N++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) last = null; N--; return item; } @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } }} 版权声明：本站原创个人文章 转载请注明出处 http://tuzhis.github.io","link":"/2016/01/15/Queue/"},{"title":"Android Studio 自定义目录后无法安装插件的分析与解决","text":"从Android Studio（以下简称AS） 0.9版本开始一直追到现在的2.1 preview1,从某个版本开始出现了这个问题。因为几乎没有影响就没有理会，早上选了个时间排查了这个问题。 环境 IDE： Android Studio 2.1 preview1 OS： Windows 10 x64 现象修改了AS配置文件目录后安装插件，重启后插件未显示安装，也无法使用。 分析分析得出AS中安装插件流程 首先在${idea.system.path}/plugins目录下生成action.script和对应插件的jar或压缩包。 重启过程中根据action.script内容解压或移动插件jar到${idea.plugins.path}/目录下。 修改${idea.config.path}/options/options.xml文件中的 ``` ``` 的value字段。 删除1中产生的action.script和插件文件。 ** 但是在更改目录后，安装插件流程1中生成的script文件正常，也能在重启后正确执行流程3，但是流程2解压或移动插件文件与流程4删除相关文件没有执行。** 原因与解决初步判断可能存在写权限的问题，导致无法创建文件和删除，估计在某个版本会修复。 ** 临时解决办法可以在安装插件后重启下AS，再手动复制插件的相关jar或者解压插件压缩包后复制插件jar到${idea.plugins.path}/目录下之后删除 {idea.system.path}/plugins目录下文件再次重启AS即可正常使用插件。**","link":"/2016/03/10/as01/"},{"title":"爬虫初探01-慕课网《Python开发简单爬虫》总结","text":"爬虫学习总结 1.说明 原课程基于python 2.7版本讲解，本总结基于python 3.5版本 原课程和以下部分引用来自慕课网 乒乓球鸡蛋老师的 ** 《Python开发简单爬虫》** 2.回顾总结2.1 爬虫简介及其价值 爬虫: 一段自动抓取互联网信息的程序 价值: 互联网数据,为我所用! 2.2 简单爬虫架构和运行流程 2.3 URL管理器和实现方法 URL管理器：管理待抓取URL集合和已抓取URL集合 防止重复抓取和循环抓取 添加新URL到待爬取集合 判断待添加URL是否在容器 判断是否还有待爬取URL 获取待爬取URL 实现方式 内存 python内存set（） 关系数据库 MySQL urls(url, is_crawled) 缓存数据库 redis 2.4 网页下载器 网页下载器：将互联网上URL对应的网页下载到本地的工具 直接下载1234567import urllib.request# 直接请求response = urllib.request.urlopen('http://python.org/')# 获取状态码，如果是200表示获取成功print response.getcode()#读取内容html = response.read() 发送数据和header1234567891011121314import urllib.parseimport urllib.request url = 'http://localhost/login.php'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'values = { 'act' : 'login', }headers = { 'User-Agent' : user_agent }data = urllib.parse.urlencode(values)req = urllib.request.Request(url, data, headers)response = urllib.request.urlopen(req)the_page = response.read()print(the_page.decode(&quot;utf8&quot;)) 添加特殊情景处理器 HTTPCookieProcessor ProxyHandler HTTPSHandler HTTPRedirectHandler 2.5 网页解析器 网页解析器：从网页中提取有价值数据的工具 提取有价值数据 新的待爬取URL 类型 正则表达式 字符串方式模糊匹配 html.parser 结构化解析 BeautifulSoup 结构化解析 lxml 结构化解析 3. 实战爬取百科数据建立python 项目和baike_spider包，baike_spider包内有spider_main、url_manager、html_downloader、html_parser、html_outputer五个模块 3.1 调度程序 spider_main.py1234567891011121314151617181920212223242526272829303132from baike_spider import url_manager, html_downloader, html_parser, html_outputerclass SpiderMain(object): def __init__(self): self.urls = url_manager.UrlManager() self.downloader = html_downloader.HtmlDownloader() self.parser = html_parser.HtmlParser() self.outputer = html_outputer.HtmlOutputer() def craw(self, root_url): count = 1 self.urls.add_new_url(root_url) while self.urls.has_new_url(): try: new_url = self.urls.get_new_url() print('craw %d : %s' % (count, new_url)) html_cont = self.downloader.download(new_url) new_urls, new_data = self.parser.parse(new_url, html_cont) self.urls.add_new_urls(new_urls) self.outputer.collect_data(new_data) if count == 10: break count = count + 1 except: print(&quot;craw failed&quot;) self.outputer.output_html() if __name__ == &quot;__main__&quot;: root_url = &quot;http://baike.baidu.com/view/21087.htm&quot; obj_spider = SpiderMain() obj_spider.craw(root_url) 3.2 URL管理器 url_manager.py12345678910111213141516171819202122232425262728293031class UrlManager(object): def __init__(self): self.new_urls = set() self.old_urls = set() def add_new_url(self, url): if url is None: return if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) def add_new_urls(self, urls): if urls is None or len(urls) == 0: return for url in urls: self.add_new_url(url) def has_new_url(self): return len(self.new_urls) != 0 def get_new_url(self): new_url = self.new_urls.pop() self.old_urls.add(new_url) return new_url 3.3 HTML下载器 html_downloader.py12345678910111213141516import urllibclass HtmlDownloader(object): def download(self, url): if url is None: return None response = urllib.request.urlopen(url) if response.getcode() != 200: return None return response.read() 3.4 HTML解析器 html_parser.py123456789101112131415161718192021222324252627282930313233343536373839404142import reimport urllibfrom bs4 import BeautifulSoupclass HtmlParser(object): def _get_new_urls(self, page_url, soup): new_urls = set() links = soup.find_all('a', href=re.compile(r&quot;/view/\\d+\\.htm&quot;)) for link in links: new_url = link['href'] new_full_url = urllib.parse.urljoin(page_url, new_url) new_urls.add(new_full_url) return new_urls def _get_new_data(self, page_url, soup): res_data = {} res_data['url'] = page_url# &lt;dd class=&quot;lemmaWgt-lemmaTitle-title&quot;&gt;&lt;h1&gt;Python&lt;/h1&gt; title_node = soup.find('dd', class_=&quot;lemmaWgt-lemmaTitle-title&quot;).find(&quot;h1&quot;) res_data['title'] = title_node.get_text()# &lt;div class=&quot;lemma-summary&quot; label-module=&quot;lemmaSummary&quot;&gt; summary_node = soup.find('div', class_=&quot;lemma-summary&quot;) res_data['summary'] = summary_node.get_text() return res_data def parse(self, page_url, html_cont): if page_url is None or html_cont is None: return soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8') new_urls = self._get_new_urls(page_url, soup) new_data = self._get_new_data(page_url, soup) return new_urls, new_data 3.5 HTML输出器 html_outputer.python12345678910111213141516171819202122232425262728293031323334353637383940414243import osclass HtmlOutputer(object): def __init__(self): self.file_name = 'output.html' self.datas = [] def collect_data(self, data): if data is None: return self.datas.append(data) def output_html(self): fout = open(self.file_name, 'w', encoding='utf-8') css = '&lt;style type=&quot;text/css&quot;&gt;body{padding:40px 50px;color:#444;font-size:14px} \\ table{width:100%;border:solid #ccc 1px;border-spacing:0}td,th{padding:10px; \\ border-top:1px solid #ccc;border-left:1px solid #ccc} \\ tbody tr:nth-child(even){background:#f5f5f5;box-shadow:0 1px 0 hsla(0,0%,100%,.8) \\ nset}th{background-color:#eee;text-align:left}&lt;/style&gt;' fout.write(&quot;&lt;html&gt;&quot;) fout.write(&quot;&lt;head&gt;&lt;meta http-equiv=\\&quot;content-type\\&quot; content=\\&quot;text/html;charset=utf-8\\&quot;&gt;%s&lt;/head&gt;&quot; % css) fout.write(&quot;&lt;body&gt;&quot;) fout.write(&quot;&lt;table&gt;&quot;) fout.write(&quot;&lt;tr&gt;&quot;) fout.write(&quot;&lt;th&gt;URL&lt;/th&gt;&quot;) fout.write(&quot;&lt;th&gt;TITLE&lt;/th&gt;&quot;) fout.write(&quot;&lt;th&gt;SUMMARY&lt;/th&gt;&quot;) fout.write(&quot;&lt;/tr&gt;&quot;) for data in self.datas: fout.write(&quot;&lt;tr&gt;&quot;) fout.write(&quot;&lt;td&gt;%s&lt;/td&gt;&quot; % data['url']) fout.write(&quot;&lt;td&gt;%s&lt;/td&gt;&quot; % data['title']) fout.write(&quot;&lt;td&gt;%s&lt;/td&gt;&quot; % data['summary']) fout.write(&quot;&lt;/tr&gt;&quot;) fout.write(&quot;&lt;/table&gt;&quot;) fout.write(&quot;&lt;/body&gt;&quot;) fout.write(&quot;&lt;/html&gt;&quot;) fout.close() os.system(self.file_name) 3.6 运行结果","link":"/2016/02/26/crawler01/"},{"title":"爬虫初探02-爬取糗事百科段子","text":"学习了简单爬虫后的练手项目，爬取糗事百科的热门段子在控制台显示 修正2016.7.25 段子正文去掉了原有的&lt;– –&gt;导致程序失效，新正则为 123'&lt;div.*?author.*?&quot;&gt;.*?&lt;a.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;/a&gt;.*?&lt;div.*?' +'content&quot;&gt;(.*?)&lt;/div&gt;(.*?)&lt;div class=&quot;stats.*?' + 'class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;.*?&lt;span class=&quot;dash.*?class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;' 说明 本文章为学习《Python爬虫实战一之爬取糗事百科段子》的二次实现，所以在文章布局和代码上都有参考 原文代码基于python 2.7版本，本文基于python3.5版本 本文对原博中已失效的正则部分进行更新，对功能、代码重构上的添加扩展和实现 目标 抓取糗事百科热门段子 过滤带有图片的段子 实现在控制台每按一次回车显示一个段子、作者、点赞数和评论数 实现步骤1. 确定URL和抓取页面代码首先打开http://www.qiushibaike.com ， 点击第二页观察网址，可以分析出8小时热门和24小时热门的网址分别对应http://www.qiushibaike.com/8hr/page/2和http://www.qiushibaike.com/hot/page/2，其中最后一位代表页数，通过改变最后一位可以获取到不同的页面。 尝试使用 1urllib.request.urlopen('http://www.qiushibaike.com/hot/page/2') 执行出错无法获取,添加header头试试 12345url = 'http://www.qiushibaike.com/8hr/page/1'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'headers = {'User-Agent': user_agent}req = urllib.request.Request(url, headers=headers)response = urllib.request.urlopen(req) 成功获取到页面。 2. 提取一页中的所有段子这一步需要构造网页解析器，本次将采用正则方式解析。 2.1 提取段子通过审查元素看下段子的布局结构 根据页面框架构造出如下解析代码，其中 item[0]匹配段子正文， item[1]匹配作者， item[2]对于有图片的段子内有图片地址。由于本次输出在控制台下进行，所以item[2]仅用于过滤有图片的段子。 12345678pattern = re.compile('&lt;div.*?author.*?&quot;&gt;.*?&lt;a.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;/a&gt;.*?&lt;div.*?' + 'content&quot;&gt;(.*?)&lt;!--.*?--&gt;.*?&lt;/div&gt;(.*?)&lt;div class=&quot;stats.*?' + 'class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;.*?&lt;span class=&quot;dash.*?class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;', re.S)items = re.findall(pattern, content)for item in items: haveImg = re.search(&quot;img&quot;, item[2]) if not haveImg: print('%s\\n作者：%s %s好笑 %s评论\\n' % (item[1], item[0], item[3], item[4])) 看下输出结果 123456789妹妹:哥哥你的愿望是什么？&lt;br/&gt;哥哥:我们家族凋零，我要壮大我们的家族，娶上十七八个老婆，生上七八十个儿子。你呢？&lt;br/&gt;妹妹:我也想壮大家族，可是我就算娶了十七八个老公，也生不出七八十个孩子啊。作者：翔→梦之堡 224好笑 4评论N年前到一小商店，偶尔去买东西，店主和我都是面熟但算不上朋友，这是前提。有次买东西是女老板卖的，后因某种问题回去交涉，只有男老板在，我一急反复说是你妈妈卖的，这东西就是他家的。男老板一脸黑色，等事情交涉好走后，回头一想，他们是夫妻店呀，难快男店主不开心。真是罪过！作者：转过街角 222好笑 1评论。。。 2.2 提取最大页数最大页数用于判断可以爬取的最大页数，对于超过最大页数的段子将采用循环方式重新从第一页开始获取。 看下页面结构 观察到最后一个class=”page-numbers”的span标签的值就是最大页数，这里通过贪婪模式来实现 1max_page_index = re.findall('&lt;a.*&lt;span class=&quot;page-numbers&quot;&gt;\\n(.*?)\\n&lt;/span&gt;', html_contents, re.S) 3. 完善细节交互，优化代码结构进一步完善，结构细化到方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# encoding: utf-8# require python version 3.x# from tuzhis.github.io# by zhisheng reference http://cuiqingcai.com/990.htmlimport reimport urllib.errorimport urllib.requestclass QSBK: def __init__(self): &quot;&quot;&quot; 初始化方法 :return: &quot;&quot;&quot; # 糗事百科8小时和24小时热门网址 self.url1 = 'http://www.qiushibaike.com/8hr/page/' self.url2 = 'http://www.qiushibaike.com/hot/page/' # 初始页码 self.page_index = 1 # 原始最大页码 self.max_page_index = 255 # 程序继续运行标志 self.enable = True def get_url(self): &quot;&quot;&quot; 生成待爬取地址 :return: 待爬取地址 &quot;&quot;&quot; # 采用取余的方式实现超过最大页码的重新载入第一页 index = self.page_index % self.max_page_index if index == 0: # 对于余数为0的修正处理 index = self.max_page_index url = self.url1 + str(index) self.page_index += 1 return url @staticmethod def download_page(url): &quot;&quot;&quot; 根据传入的地址下载页码内容 :param url: :return:对应的html页面内容 &quot;&quot;&quot; try: user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' headers = {'User-Agent': user_agent} req = urllib.request.Request(url, headers=headers) response = urllib.request.urlopen(req) return response.read().decode('utf-8') except urllib.error.URLError as e: if hasattr(e, 'reason'): print('Failed to reach a server.') print('Reason: ', e.reason) elif hasattr(e, 'code'): print(&quot;The server couldn't fulfill the request.&quot;) print('Error code: ', e.code) return None def parse(self, html_contents): &quot;&quot;&quot; 解析传入的html内容 :param html_contents: :return: 当前页所有不带图片的段子 &quot;&quot;&quot; # 初次解析写入最大页数 if self.max_page_index == 255: max_index = re.findall('&lt;a.*&lt;span class=&quot;page-numbers&quot;&gt;\\n(.*?)\\n&lt;/span&gt;', html_contents, re.S) if max_index: self.max_page_index = int(max_index[0]) stories = [] stories_pattern = re.compile('&lt;div.*?author.*?&quot;&gt;.*?&lt;a.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;/a&gt;.*?&lt;div.*?' + 'content&quot;&gt;(.*?)&lt;!--.*?--&gt;.*?&lt;/div&gt;(.*?)&lt;div class=&quot;stats.*?' + 'class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;.*?&lt;span class=&quot;dash.*?class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;', re.S) items = re.findall(stories_pattern, html_contents) for item in items: have_img = re.search(&quot;img&quot;, item[2]) if not have_img: # br标签替换为换行 text = re.sub('&lt;br/&gt;', &quot;\\n&quot;, item[1]) stories.append([text.strip(), item[0].strip(), item[3].strip(), item[4].strip()]) return stories def print_story(self, stories): &quot;&quot;&quot; 输出一条段子回车继续显示 :param stories: :return: &quot;&quot;&quot; for story in stories: print('\\n%s\\n作者：%s %s好笑 %s评论' % (story[0], story[1], story[2], story[3])) input_a = input('回车继续输出段子，按Q结束\\n') if input_a == 'Q' or input_a == 'q': self.enable = False return def craw(self): &quot;&quot;&quot; 爬虫总调度方法 :return: &quot;&quot;&quot; while self.enable: url = self.get_url() html_contents = self.download_page(url) if not html_contents: print(&quot;Failed to load the page&quot;) return stories = self.parse(html_contents) self.print_story(stories)if __name__ == '__main__': obj_spider = QSBK() obj_spider.craw() 运行结果","link":"/2016/02/29/crawler02/"},{"title":"Edison开发板系列-Edison安装python3.5","text":"需要在Edison for Arduino上安装Python 3.5以上版本，记录下步骤 步骤1.编译生成123456cd /homewget --no-check-certificate http://mirrors.sohu.com/python/3.5.2/Python-3.5.2.tgztar -xvf Python-3.5.2.tgzcd Python-3.5.2/./configure --with-pydebugmake -s -j2 编译过程前４分钟无输出，继续等待到9分钟结束。 2. 替换库12rm /usr/bin/pythonln -s $(pwd)/python /usr/bin/python 测试了下没有发现什么问题，尽情使用吧 参考 https://docs.python.org/devguide/setup.htmlhttps://communities.intel.com/message/276542#276542","link":"/2016/09/17/edison01/"},{"title":"自用的hexo快捷批处理","text":"原创的Hexo快捷操作批处理，用了一段时间还算顺手，发出来共享。目前版本0.4 ，欢迎反馈扩展和修正。 使用方法： 修改代码中相应的变量 保存成bat后缀放入hexo博客根目录，快捷方式‘blog’放入path环境变量找得到的地方。 win+r 敲入相应blog命令。 示例：blog … 打开hexo命令行 blog n test1 … 新建text1.md后用subl（sublime打开）blog e test1 … 编辑test1.md文件blog d … hexo d -g 编译部署后打开预览blog r test1 … 删除test1.mdblog f … 打开_posts目录 blog i … 打开图床 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@ECHO offtitle hexo PUSHD %~DP0 @rem hexo 快捷脚本 @rem 版本:0.4@rem 作者:tuzhis@rem 示例：@rem &gt;blog ... 打开hexo命令行 @rem &gt;blog n test1 ... 新建text1.md后用subl（sublime打开）@rem &gt;blog e test1 ... 编辑test1.md文件@rem &gt;blog d ... hexo d -g 编译部署后打开预览@rem &gt;blog r test1 ... 删除test1.md@rem &gt;blog f ... 打开_posts目录 @rem &gt;blog i ... 打开图床 @rem 博客地址set site=http://tuzhis.github.io@rem 浏览器路径set browser=&quot;D:\\Program Files\\greenSoft\\Chrome\\Chrome\\chrome.exe&quot;@rem 图床地址set imgsite=https://portal.qiniu.com/if &quot;%1&quot;==&quot;&quot; ( start &quot;hexo&quot; Goto Exit)if &quot;%1&quot;==&quot;n&quot; Goto Newif &quot;%1&quot;==&quot;e&quot; Goto Editif &quot;%1&quot;==&quot;d&quot; Goto Deployif &quot;%1&quot;==&quot;r&quot; Goto Removeif &quot;%1&quot;==&quot;f&quot; Goto Folderif &quot;%1&quot;==&quot;i&quot; Goto Image:Newcmd /c hexo n %2Goto Edit :Deploycmd /c hexo d -gstart &quot; &quot; %browser% %site%Goto Exit:Editsubl source\\_posts\\%2.mdGoto Exit:Removedel source\\_posts\\%2*Goto Exit:Folderexplorer source\\_posts\\Goto Exit:Imagestart &quot;hexo&quot; %browser% %imgsite%Goto Exit:ExitPopd","link":"/2016/01/17/hexo-batch/"},{"title":"kmp探索","text":"初看KMP算法有点晕，基本懂了，做个记录。 理解过程建议先阅读《字符串匹配的KMP算法》,看完对kmp的流程和next的含义了解的很透彻了，之后数据结构高分笔记中有个关于next的快速求解的也可以看一下，最后深入的在算法4中有详细介绍，至此，完结，详细的以后写。","link":"/2016/04/27/kmp/"},{"title":"nodejs开发---webstorm调试v8debug is not defined解决","text":"开发nodejs需要的设置项记录 解决方式添加–expose_debug_as=v8debug 参数 到运行配置中的 Node parameters","link":"/2016/07/01/nodejs01/"},{"title":"USB控制器黄色感叹号相关问题的一种情况与解决","text":"记录下晚上耗费大量时间追查移动硬盘中的win10 vhd启动报inaccessible_boot_device蓝屏错误的情况。 过程追查过程异常艰辛，从引导到驱动和各组件查了个遍，慢慢的发现是引导vhd后无法继续加载移动硬盘中的文件所以无法继续启动。用vm虚拟机启动了系统辅助排查，发现usb控制器有黄色感叹号，在驱动详情页提示系统资源不足 无法完成api。搜索没有找到正确的解决方法，继续比对usb设备的注册表和驱动文件，最后发现在注册表**[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class{36fc9e60-c465-11cf-8056-444553540000}]项下多了一个”LowerFilters”=” “**搜索此属性果然会导致控制器异常，删除LowerFilters”=” “再重启，解决~ 错误信息以下提示都有可能是同样的原因，可以看下解决方法 usb控制器黄色感叹号 系统资源不足 无法完成api USB设备中的VHD引导后inaccessible_boot_device 解决方法查看 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class{36fc9e60-c465-11cf-8056-444553540000}]项下是否有LowerFilters的值，有的话删除之","link":"/2016/03/25/p1/"},{"title":"算法4学习-2.1 初级排序算法(选择排序、插入排序、希尔排序)","text":"这一章的内容开始多了，怎么说呢，代码都是见过的，但是书中的解析太迷人了。粗略的看了这一章，粗略记录,理解不透的回顾的时候再补充。 排序算法类模板 排序类的算法都会使用两个方法操作数据:less()方法对元素进行比较，exch()方法将元素交换位置。将数据操作限制在这两个方法中使得代码的可读性和可移植性更好。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Created by tuzhis on 2016年1月16日. */public class SortTemplet { public static void sort(Comparable[] a) { }; private static boolean less(Comparable v, Comparable w) { // 比较元素 return v.compareTo(w) &lt; 0; } private static void exch(Comparable[] a, int i, int j) { // 交换数组元素 Comparable t = a[i]; a[i] = a[j]; a[j] = t; } private static void show(Comparable[] a) { // 单行打印数组 for (int i = 0; i &lt; a.length; i++) StdOut.print(a[i] + &quot; &quot;); StdOut.println(); } public static boolean isSorted(Comparable[] a) { // 测试数组元素是否有序 for (int i = 1; i &lt; a.length; i++) if (less(a[i], a[i - 1])) return false; return true; } public static void main(String[] args) { String[] a = In.readString(); sort(a); assert isSorted(a); show(a); }} 选择排序 首先找到数组中最小的元素,其次,将它和数组的第一个元素交换位置。 123456789101112131415public static class Selection extends SortTemplet { // 选择排序 public static void sort(Comparable[] a) { // 将a[] 按升序排列 int N = a.length; for (int i = 0; i &lt; N; i++) { // 将a[i]和a[i+1..N]中最小的元素交换 int min = i; //最小元素索引 for (int j = i + 1; j &lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); } }} 插入排序 当前索引左边的元素都是有序的，但他们最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组的排序就完成了。 123456789101112public static class Insertion extends SortTemplet { // 插入排序 public static void sort(Comparable[] a) { // 将a[] 按升序排列 int N = a.length; for (int i = 1; i &lt; N; i++) { // 将a[i]插入到 a[i-1]、a[i-2]、 a[i-3].。。中 for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } }} 希尔排序 对于大规模乱序数组插入排序数组很慢。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。 1234567891011121314151617public static class shell extends SortTemplet { // 希尔排序 public static void sort(Comparable[] a) { // 将a[] 按升序排列 int N = a.length; int h = 1; while (h &lt; N / 3) h = 3 * h + 1; // 1, 4, 13, 40... while (h &gt;= 1) { for (int i = h; i &lt; N; i++) { for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) exch(a, j, j - h); } h = h / 3; } }} FAQ1.定义一个可比较的数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package FAQ;/** * Created by tuzhis on 2016年1月17日. */public class Date implements Comparable&lt;Date&gt; { private final int day; private final int month; private final int year; public Date(int d, int m, int y) { day = d; month = m; year = y; } public int day() { return day; } public int month() { return month; } public int year() { return year; } @Override public int compareTo(Date that) { // TODO Auto-generated method stub if (this.year &gt; that.year) return +1; if (this.year &lt; that.year) return -1; if (this.month &gt; that.month) return +1; if (this.month &lt; that.month) return -1; if (this.day &gt; that.day) return +1; if (this.day &lt; that.day) return -1; return 0; } public String toString() { return month + &quot;/&quot; + day + &quot;/&quot; + year; }} 2. 随机生成测试数据测试12345678910111213import edu.princeton.cs.algs4.StdOut;import edu.princeton.cs.algs4.StdRandom;public static void main(String[] args) { int N = 200; //测试数据个数 Integer a[] = new Integer[N]; for (int i = 0; i &lt; N; i++) a[i] = StdRandom.uniform(1, 100); //重载生成范围内整数 // Selection.sort(a); Insertion.sort(a); assert isSorted(a); show(a);}","link":"/2016/01/16/sort1/"},{"title":"SpringBoot系列-文件上传处理","text":"前言SpringBoot开发遇到文件上传的问题，getRealPath(“/upload”)在SpringBoot中对应的路径在tmp目录下，每次启动都会改变，不再适合保存文件。本文记录下SpringBoot框架下上传文件到自定义目录并生成对应可存储的网络路径方法。 步骤1application.properties中添加本地路径的配置 1upload.path = H:/images 步骤二创建类继承WebMvcConfigurerAdapter并添加路径映射 1234567891011121314@Configurationpublic class MyWebConfigurer extends WebMvcConfigurerAdapter { @Autowired private Environment env; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + env.getProperty(&quot;upload.path&quot;) + &quot;/&quot;); super.addResourceHandlers(registry); }} 步骤三上传文件处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Controllerpublic class UploadController { // The Environment object will be used to read parameters from the // application.properties configuration file @Autowired private Environment env; @RequestMapping(value = &quot;/uploadFile&quot;, method = RequestMethod.POST) @ResponseBody public ResponseEntity&lt;?&gt; uploadFile( @RequestParam(&quot;file&quot;) MultipartFile multipartFile) { /**获取配置的本地路径* */ String rootPathDir = env.getProperty(&quot;upload.path&quot;); /**构建按照日期存储的本地路径**/ SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy/MM/dd/HH&quot;); String fullPathDir = rootPathDir + File.separator + dateFormat.format(new Date()); /**根据本地路径创建目录**/ File fullPathFile = new File(fullPathDir); if (!fullPathFile.exists()) fullPathFile.mkdirs(); /** 获取文件的后缀* */ String suffix = multipartFile.getOriginalFilename().substring( multipartFile.getOriginalFilename().lastIndexOf(&quot;.&quot;)); /** 使用UUID生成文件名称* */ String fileName = UUID.randomUUID().toString() + suffix; /** 拼成完整的文件保存路径加文件* */ String filePath = fullPathFile + File.separator + fileName; /** 文件输出流* */ File file = new File(filePath); try (FileOutputStream fileOutputStream = new FileOutputStream(file); BufferedOutputStream stream = new BufferedOutputStream(fileOutputStream)) { stream.write(multipartFile.getBytes()); /** 打印出上传到服务器的文件的本地路径和网络路径* */ System.out.println(&quot;****************&quot; + filePath + &quot;**************&quot;); System.out.println(&quot;/images/&quot; + dateFormat.format(new Date()) + &quot;/&quot; + fileName); } catch (Exception e) { System.out.println(e.getMessage()); return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST); } return new ResponseEntity&lt;&gt;(HttpStatus.OK); }} 运行结果控制台输出，网络路径用于存储到数据库 12****************H:\\images\\2016\\06\\14\\08\\489b66e4-438b-443a-ab21-5c93de35ae9a.jpg**************/images/2016/06/14/08/489b66e4-438b-443a-ab21-5c93de35ae9a.jpg 参考 SpringMVC—&gt;Controller获得上传文件的绝对路径 Spring Boot 静态资源处理 spring boot应用启动原理分析","link":"/2016/06/13/springboot01/"},{"title":"我为什么需要一个博客","text":"时不时的想起需要一个博客，既没文笔也没干货，但是总是有这想法，先搭建起来好了，慢慢补充，也许能顺便整理笔记和提高（呵呵呵。。","link":"/2015/09/29/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"算法4","slug":"算法4","link":"/tags/%E7%AE%97%E6%B3%954/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Android UI","slug":"Android-UI","link":"/tags/Android-UI/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Edison","slug":"Edison","link":"/tags/Edison/"},{"name":"开发板","slug":"开发板","link":"/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"},{"name":"原创","slug":"原创","link":"/tags/%E5%8E%9F%E5%88%9B/"},{"name":"批处理","slug":"批处理","link":"/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"查找算法","slug":"查找算法","link":"/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"问题解决","slug":"问题解决","link":"/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"usb","slug":"usb","link":"/tags/usb/"},{"name":"注册表","slug":"注册表","link":"/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Java Web","slug":"Java-Web","link":"/tags/Java-Web/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"环境配置","slug":"环境配置","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"爬虫","slug":"爬虫","link":"/categories/%E7%88%AC%E8%99%AB/"},{"name":"Edison","slug":"Edison","link":"/categories/Edison/"},{"name":"小工具","slug":"小工具","link":"/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"name":"IDE","slug":"环境配置/IDE","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/IDE/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"技巧","slug":"技巧","link":"/categories/%E6%8A%80%E5%B7%A7/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"默认","slug":"默认","link":"/categories/%E9%BB%98%E8%AE%A4/"},{"name":"技巧","slug":"环境配置/IDE/技巧","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/IDE/%E6%8A%80%E5%B7%A7/"}]}